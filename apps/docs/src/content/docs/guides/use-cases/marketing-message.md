---
title: "ë§ˆì¼€íŒ… ë©”ì‹œì§€"
description: "ì¹œêµ¬í†¡ê³¼ SMSë¥¼ í™œìš©í•œ ë§ˆì¼€íŒ… ë©”ì‹œì§€ ë°œì†¡ ê°€ì´ë“œì…ë‹ˆë‹¤."
---

ë§ˆì¼€íŒ… ë©”ì‹œì§€ëŠ” í”„ë¡œëª¨ì…˜, ì´ë²¤íŠ¸ ì•ˆë‚´, ì¿ í° ë°œì†¡ ë“± ê³ ê° ì°¸ì—¬ë¥¼ ìœ ë„í•˜ëŠ” ë©”ì‹œì§€ì…ë‹ˆë‹¤. ìˆ˜ì‹  ë™ì˜ë¥¼ ë°›ì€ ê³ ê°ì—ê²Œë§Œ ë°œì†¡í•  ìˆ˜ ìˆìœ¼ë©°, ì±„ë„ ì„ íƒê³¼ ë°œì†¡ ì „ëµì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ì´ ê°€ì´ë“œì—ì„œëŠ” ì¹œêµ¬í†¡ê³¼ SMSë¥¼ í™œìš©í•œ ë§ˆì¼€íŒ… ë©”ì‹œì§€ ë°œì†¡ ë°©ë²•ì„ ì•Œì•„ë´…ë‹ˆë‹¤.

## ì‹œë‚˜ë¦¬ì˜¤ ì„¤ëª…

ë§ˆì¼€íŒ… ë©”ì‹œì§€ì˜ ì£¼ìš” ìœ í˜•:

1. **í”„ë¡œëª¨ì…˜ ì•ˆë‚´**: í• ì¸ í–‰ì‚¬, íŠ¹ê°€ ìƒí’ˆ ì•ˆë‚´
2. **ì´ë²¤íŠ¸ ì´ˆëŒ€**: ëŸ°ì¹­ íŒŒí‹°, íŒ¬ë¯¸íŒ…, ì›Œí¬ìƒµ
3. **ì¿ í° ë°œì†¡**: ìƒì¼ ì¿ í°, ì›°ì»´ ì¿ í°, ë³µê·€ ì¿ í°
4. **ì‹ ìƒí’ˆ ì•ˆë‚´**: ì‹œì¦Œ ì‹ ìƒí’ˆ, ì‹ ë©”ë‰´ ëŸ°ì¹­

ë§ˆì¼€íŒ… ë©”ì‹œì§€ì˜ í•µì‹¬ ê³ ë ¤ì‚¬í•­:
- ìˆ˜ì‹  ë™ì˜ ì—¬ë¶€ í™•ì¸
- ë°œì†¡ ì‹œê°„ ìµœì í™”
- ìŠ¤íŒ¸ í•„í„°ë§ íšŒí”¼
- ë¹„ìš© ëŒ€ë¹„ íš¨ê³¼ ì¸¡ì •

## ë©”ì‹œì§€ íƒ€ì… ì„ íƒ

### ì¹œêµ¬í†¡ vs SMS ë¹„êµ

| ê¸°ì¤€ | ì¹œêµ¬í†¡ | SMS |
|------|--------|-----|
| ë°œì†¡ ì¡°ê±´ | ì¹´ì¹´ì˜¤ ì±„ë„ ì¹œêµ¬ + ìˆ˜ì‹  ë™ì˜ | ìˆ˜ì‹  ë™ì˜ë§Œ |
| ë¹„ìš© | ê±´ë‹¹ 5~15ì› | ê±´ë‹¹ 15~30ì› |
| ì˜¤í”ˆìœ¨ | 60~80% | 70~90% |
| í¬ë§·íŒ… | ì´ë¯¸ì§€, ë²„íŠ¼ ì§€ì› | í…ìŠ¤íŠ¸ë§Œ |
| ë„ë‹¬ë¥  | ì¹´ì¹´ì˜¤í†¡ ì‚¬ìš©ìë§Œ | ëª¨ë“  íœ´ëŒ€í° |

### ì„ íƒ ê¸°ì¤€

```
ì¹œêµ¬í†¡ ê¶Œì¥:
- ë¸Œëœë“œ ì¶©ì„±ë„ê°€ ë†’ì€ ê³ ê°
- ì´ë¯¸ ì¹´ì¹´ì˜¤ ì±„ë„ ì¹œêµ¬
- ì´ë¯¸ì§€/ë²„íŠ¼ì´ í•„ìš”í•œ ìº í˜ì¸
- ëŒ€ëŸ‰ ë°œì†¡ìœ¼ë¡œ ë¹„ìš© ì ˆê° í•„ìš”

SMS ê¶Œì¥:
- ì‹ ê·œ ê³ ê° (ì±„ë„ ì¹œêµ¬ ì•„ë‹˜)
- ê¸´ê¸‰ì„± ìˆëŠ” ë©”ì‹œì§€
- ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ë©”ì‹œì§€
- ëª¨ë“  ê³ ê°ì—ê²Œ ë„ë‹¬ í•„ìš”
```

## ì „ì²´ ì½”ë“œ ì˜ˆì œ

### 1. KMsg ì¸ìŠ¤í„´ìŠ¤ êµ¬ì„±

```ts
import { KMsg } from "@k-msg/messaging";
import { IWINVProvider } from "@k-msg/provider";
import { SolapiProvider } from "@k-msg/provider/solapi";

const kmsg = new KMsg({
  providers: [
    new IWINVProvider({
      apiKey: process.env.IWINV_API_KEY!,
      baseUrl: "https://alimtalk.bizservice.iwinv.kr",
    }),
    new SolapiProvider({
      apiKey: process.env.SOLAPI_API_KEY!,
      apiSecret: process.env.SOLAPI_API_SECRET!,
      defaultFrom: "01000000000",
    }),
  ],
  routing: {
    defaultProviderId: "solapi",
    byType: {
      FRIENDTALK: "iwinv",
      SMS: "solapi",
      LMS: "solapi",
    },
  },
  defaults: {
    kakao: {
      plusId: process.env.KAKAO_PLUS_ID!, // ì¹´ì¹´ì˜¤ í”ŒëŸ¬ìŠ¤ ì¹œêµ¬ ID
    },
  },
});
```

### 2. ì¹œêµ¬í†¡ ë§ˆì¼€íŒ… ë©”ì‹œì§€

```ts
interface MarketingTarget {
  phoneNumber: string;
  name: string;
  isKakaoFriend: boolean;
  consentedAt: Date;
}

async function sendFriendTalkMarketing(
  targets: MarketingTarget[],
  campaign: {
    title: string;
    content: string;
    imageUrl?: string;
    buttonUrl?: string;
    buttonText?: string;
  },
) {
  // ì¹œêµ¬í†¡ì€ ì±„ë„ ì¹œêµ¬ì—ê²Œë§Œ ë°œì†¡
  const friendTalkTargets = targets.filter((t) => t.isKakaoFriend);

  const results = [];

  for (const target of friendTalkTargets) {
    const result = await kmsg.send({
      type: "FRIENDTALK",
      to: target.phoneNumber,
      text: campaign.content.replace("#{ì´ë¦„}", target.name),
      // ì´ë¯¸ì§€ì™€ ë²„íŠ¼ì´ ìˆëŠ” ê²½ìš°
      // kakao: {
      //   imageUrl: campaign.imageUrl,
      //   button: {
      //     name: campaign.buttonText,
      //     url: campaign.buttonUrl,
      //   },
      // },
    });

    results.push({
      phoneNumber: target.phoneNumber,
      success: result.isSuccess,
      messageId: result.isSuccess ? result.value.messageId : undefined,
      error: result.isFailure ? result.error.message : undefined,
    });
  }

  return results;
}

// ì‚¬ìš© ì˜ˆì‹œ
const results = await sendFriendTalkMarketing(
  [
    { phoneNumber: "01011112222", name: "í™ê¸¸ë™", isKakaoFriend: true, consentedAt: new Date() },
    { phoneNumber: "01033334444", name: "ê¹€ì² ìˆ˜", isKakaoFriend: true, consentedAt: new Date() },
  ],
  {
    title: "ë´„ë§ì´ ì„¸ì¼",
    content: "#{ì´ë¦„}ë‹˜, ë´„ë§ì´ íŠ¹ë³„ ì„¸ì¼ì„ ë†“ì¹˜ì§€ ë§ˆì„¸ìš”!\nìµœëŒ€ 50% í• ì¸ + ë¬´ë£Œë°°ì†¡\nê¸°ê°„: 2ì›” 25ì¼~28ì¼",
  },
);
```

### 3. SMS ë§ˆì¼€íŒ… ë©”ì‹œì§€

```ts
async function sendSMSMarketing(
  targets: MarketingTarget[],
  message: string,
) {
  const results = [];

  for (const target of targets) {
    const personalizedMessage = message.replace("#{ì´ë¦„}", target.name);
    
    const result = await kmsg.send({
      to: target.phoneNumber,
      text: personalizedMessage,
    });

    results.push({
      phoneNumber: target.phoneNumber,
      success: result.isSuccess,
      messageId: result.isSuccess ? result.value.messageId : undefined,
      error: result.isFailure ? result.error.message : undefined,
    });
  }

  return results;
}

// ì‚¬ìš© ì˜ˆì‹œ
await sendSMSMarketing(
  [
    { phoneNumber: "01011112222", name: "í™ê¸¸ë™", isKakaoFriend: false, consentedAt: new Date() },
    { phoneNumber: "01033334444", name: "ê¹€ì² ìˆ˜", isKakaoFriend: false, consentedAt: new Date() },
  ],
  "[ë´„ë§ì´ ì„¸ì¼] #{ì´ë¦„}ë‹˜, ìµœëŒ€ 50% í• ì¸! 2/25~28. ê±°ë¶€ëŠ” 080-XXX-XXXX",
);
```

### 4. ëŒ€ëŸ‰ ë°œì†¡ (ë°°ì¹˜ ì²˜ë¦¬)

```ts
async function sendBulkMarketing(
  targets: MarketingTarget[],
  campaign: {
    friendTalkContent: string;
    smsContent: string;
  },
) {
  // ì¹œêµ¬í†¡ ëŒ€ìƒê³¼ SMS ëŒ€ìƒ ë¶„ë¦¬
  const friendTalkTargets = targets.filter((t) => t.isKakaoFriend);
  const smsTargets = targets.filter((t) => !t.isKakaoFriend);

  const allResults = [];

  // ì¹œêµ¬í†¡ ì¼ê´„ ë°œì†¡
  if (friendTalkTargets.length > 0) {
    const friendTalkMessages = friendTalkTargets.map((t) => ({
      type: "FRIENDTALK" as const,
      to: t.phoneNumber,
      text: campaign.friendTalkContent.replace("#{ì´ë¦„}", t.name),
    }));

    const ftResults = await kmsg.send(friendTalkMessages);
    
    ftResults.results.forEach((result, index) => {
      allResults.push({
        phoneNumber: friendTalkTargets[index].phoneNumber,
        channel: "FRIENDTALK",
        success: result.isSuccess,
      });
    });
  }

  // SMS ì¼ê´„ ë°œì†¡
  if (smsTargets.length > 0) {
    const smsMessages = smsTargets.map((t) => ({
      to: t.phoneNumber,
      text: campaign.smsContent.replace("#{ì´ë¦„}", t.name),
    }));

    const smsResults = await kmsg.send(smsMessages);
    
    smsResults.results.forEach((result, index) => {
      allResults.push({
        phoneNumber: smsTargets[index].phoneNumber,
        channel: "SMS",
        success: result.isSuccess,
      });
    });
  }

  return {
    total: targets.length,
    friendTalkCount: friendTalkTargets.length,
    smsCount: smsTargets.length,
    results: allResults,
  };
}

// ì‚¬ìš© ì˜ˆì‹œ
const bulkResult = await sendBulkMarketing(
  // DBì—ì„œ ì¡°íšŒí•œ ë§ˆì¼€íŒ… ëŒ€ìƒ
  await getMarketingTargets(),
  {
    friendTalkContent: "#{ì´ë¦„}ë‹˜, íŠ¹ë³„ í˜œíƒì´ ë„ì°©í–ˆì–´ìš”!\ní´ë¦­í•´ì„œ í™•ì¸í•˜ì„¸ìš” ğŸ‘‰",
    smsContent: "[íŠ¹ë³„í˜œíƒ] #{ì´ë¦„}ë‹˜, ì „ìš© ì¿ í°ì´ ë°œê¸‰ë˜ì—ˆìŠµë‹ˆë‹¤. ê±°ë¶€ëŠ” 080-XXX-XXXX",
  },
);

console.log(`ë°œì†¡ ì™„ë£Œ: ì¹œêµ¬í†¡ ${bulkResult.friendTalkCount}ê±´, SMS ${bulkResult.smsCount}ê±´`);
```

### 5. ìƒì¼ ì¿ í° ë°œì†¡

```ts
interface BirthdayTarget {
  phoneNumber: string;
  name: string;
  birthDate: Date;
  couponCode: string;
}

async function sendBirthdayCoupon(target: BirthdayTarget) {
  const month = target.birthDate.getMonth() + 1;
  const day = target.birthDate.getDate();

  const result = await kmsg.send({
    type: "FRIENDTALK",
    to: target.phoneNumber,
    text: `ğŸ‚ ${target.name}ë‹˜, ìƒì¼ì„ ì§„ì‹¬ìœ¼ë¡œ ì¶•í•˜ë“œë¦½ë‹ˆë‹¤!

ğŸ ìƒì¼ íŠ¹ë³„ ì¿ í°
ì½”ë“œ: ${target.couponCode}
í• ì¸: 20% (ìµœëŒ€ 1ë§Œì›)
ê¸°ê°„: ${month}/${day} ~ ${month}/${day + 7}

ìƒì¼ì„ í•¨ê»˜ ì¶•í•˜í•´ì£¼ì…”ì„œ ê°ì‚¬í•©ë‹ˆë‹¤.`,
  });

  return result;
}
```

## ìˆ˜ì‹  ë™ì˜ ê´€ë¦¬

### ë™ì˜ í™•ì¸ í•¨ìˆ˜

```ts
interface ConsentInfo {
  phoneNumber: string;
  marketingConsent: boolean;
  consentedAt?: Date;
  channel: "KAKAO" | "SMS" | "ALL";
}

async function checkMarketingConsent(phoneNumber: string): Promise<ConsentInfo> {
  // DBì—ì„œ ë™ì˜ ì •ë³´ ì¡°íšŒ (ì˜ì‚¬ ì½”ë“œ)
  const consent = await db.marketingConsents.findUnique({
    where: { phoneNumber },
  });

  if (!consent) {
    return {
      phoneNumber,
      marketingConsent: false,
      channel: "ALL",
    };
  }

  return {
    phoneNumber,
    marketingConsent: consent.marketingConsent,
    consentedAt: consent.consentedAt,
    channel: consent.channel,
  };
}

// ë°œì†¡ ì „ ë™ì˜ í™•ì¸
async function sendWithConsentCheck(
  target: MarketingTarget,
  message: string,
  channel: "FRIENDTALK" | "SMS",
) {
  const consent = await checkMarketingConsent(target.phoneNumber);

  if (!consent.marketingConsent) {
    return {
      success: false,
      reason: "ìˆ˜ì‹  ë™ì˜ ì—†ìŒ",
    };
  }

  // ë™ì˜ ì±„ë„ í™•ì¸
  if (channel === "FRIENDTALK" && consent.channel === "SMS") {
    // ì¹œêµ¬í†¡ ë™ì˜ê°€ ì—†ìœ¼ë©´ SMSë¡œ ëŒ€ì²´
    return kmsg.send({ to: target.phoneNumber, text: message });
  }

  if (channel === "FRIENDTALK") {
    return kmsg.send({ type: "FRIENDTALK", to: target.phoneNumber, text: message });
  }

  return kmsg.send({ to: target.phoneNumber, text: message });
}
```

## ì—ëŸ¬ ì²˜ë¦¬ ë°©ë²•

### ë°œì†¡ ì‹¤íŒ¨ ì²˜ë¦¬

```ts
async function sendMarketingWithErrorHandling(
  targets: MarketingTarget[],
  message: string,
) {
  const results = {
    success: 0,
    failed: 0,
    invalidNumbers: 0,
    consentMissing: 0,
  };

  for (const target of targets) {
    const consent = await checkMarketingConsent(target.phoneNumber);
    
    if (!consent.marketingConsent) {
      results.consentMissing++;
      continue;
    }

    const result = await kmsg.send({
      to: target.phoneNumber,
      text: message,
    });

    if (result.isSuccess) {
      results.success++;
    } else {
      results.failed++;
      
      if (result.error.code === "INVALID_PHONE_NUMBER") {
        results.invalidNumbers++;
      }
    }
  }

  return results;
}
```

### ë°œì†¡ ê²°ê³¼ ë¦¬í¬íŠ¸

```ts
interface SendReport {
  campaignId: string;
  totalTargets: number;
  successCount: number;
  failedCount: number;
  channelBreakdown: {
    friendTalk: number;
    sms: number;
  };
  failedReasons: Record<string, number>;
}

async function generateSendReport(
  campaignId: string,
  results: Array<{ channel: string; success: boolean; error?: string }>,
): Promise<SendReport> {
  const report: SendReport = {
    campaignId,
    totalTargets: results.length,
    successCount: results.filter((r) => r.success).length,
    failedCount: results.filter((r) => !r.success).length,
    channelBreakdown: {
      friendTalk: results.filter((r) => r.channel === "FRIENDTALK").length,
      sms: results.filter((r) => r.channel === "SMS").length,
    },
    failedReasons: {},
  };

  // ì‹¤íŒ¨ ì›ì¸ ì§‘ê³„
  results
    .filter((r) => !r.success && r.error)
    .forEach((r) => {
      report.failedReasons[r.error!] = (report.failedReasons[r.error!] || 0) + 1;
    });

  return report;
}
```

## ëª¨ë²” ì‚¬ë¡€

### 1. ë°œì†¡ ì‹œê°„ ìµœì í™”

```ts
// ìµœì  ë°œì†¡ ì‹œê°„ í™•ì¸ (ì—…ì¢…ë³„ ìƒì´)
const OPTIMAL_HOURS = {
  morning: { start: 9, end: 11 },    // ì˜¤ì „ 9~11ì‹œ
  afternoon: { start: 14, end: 16 }, // ì˜¤í›„ 2~4ì‹œ
  evening: { start: 18, end: 20 },   // ì €ë… 6~8ì‹œ
};

function isInOptimalTime(): boolean {
  const hour = new Date().getHours();
  
  return (
    (hour >= OPTIMAL_HOURS.morning.start && hour <= OPTIMAL_HOURS.morning.end) ||
    (hour >= OPTIMAL_HOURS.afternoon.start && hour <= OPTIMAL_HOURS.afternoon.end) ||
    (hour >= OPTIMAL_HOURS.evening.start && hour <= OPTIMAL_HOURS.evening.end)
  );
}

// ë°œì†¡ ì „ ì‹œê°„ í™•ì¸
if (!isInOptimalTime()) {
  console.log("í˜„ì¬ëŠ” ìµœì  ë°œì†¡ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤. ë°œì†¡ì„ ì˜ˆì•½í•©ë‹ˆë‹¤.");
  // íì— ì €ì¥ í›„ ì ì ˆí•œ ì‹œê°„ì— ë°œì†¡
}
```

### 2. 080 ìˆ˜ì‹ ê±°ë¶€ ë²ˆí˜¸ í¬í•¨

```ts
// SMSì— ìˆ˜ì‹ ê±°ë¶€ ë²ˆí˜¸ í•„ìˆ˜ í¬í•¨
const smsContent = `${message}

ê±°ë¶€: 080-XXX-XXXX`;
```

### 3. ë°œì†¡ ì£¼ê¸° ê´€ë¦¬

```ts
// ë™ì¼ ê³ ê°ì—ê²Œ ê³¼ë„í•œ ë°œì†¡ ë°©ì§€
const MIN_DAYS_BETWEEN_MARKETING = 7; // ìµœì†Œ 7ì¼ ê°„ê²©

async function canSendMarketing(phoneNumber: string): Promise<boolean> {
  const lastSent = await db.marketingLogs.findFirst({
    where: { phoneNumber },
    orderBy: { sentAt: "desc" },
  });

  if (!lastSent) return true;

  const daysSinceLastSent = Math.floor(
    (Date.now() - lastSent.sentAt.getTime()) / (1000 * 60 * 60 * 24),
  );

  return daysSinceLastSent >= MIN_DAYS_BETWEEN_MARKETING;
}
```

### 4. A/B í…ŒìŠ¤íŠ¸

```ts
async function runABTest(
  targets: MarketingTarget[],
  variants: {
    a: string;
    b: string;
  },
  sampleRatio: number = 0.1, // 10%ë§Œ í…ŒìŠ¤íŠ¸
) {
  const sampleSize = Math.floor(targets.length * sampleRatio);
  const sampleTargets = targets.slice(0, sampleSize);
  const remainingTargets = targets.slice(sampleSize);

  const groupA = sampleTargets.filter((_, i) => i % 2 === 0);
  const groupB = sampleTargets.filter((_, i) => i % 2 === 1);

  // A ê·¸ë£¹ ë°œì†¡
  const resultsA = await sendSMSMarketing(groupA, variants.a);
  
  // B ê·¸ë£¹ ë°œì†¡
  const resultsB = await sendSMSMarketing(groupB, variants.b);

  return {
    variantA: { count: groupA.length, successRate: resultsA.filter((r) => r.success).length / groupA.length },
    variantB: { count: groupB.length, successRate: resultsB.filter((r) => r.success).length / groupB.length },
    remainingTargets, // ìŠ¹ì variantë¡œ ë‚˜ë¨¸ì§€ ë°œì†¡
  };
}
```

## ìš”ì•½

- ì±„ë„ ì„ íƒì€ ê³ ê° íŠ¹ì„±(ì±„ë„ ì¹œêµ¬ ì—¬ë¶€)ì— ë”°ë¼ ê²°ì •í•˜ì„¸ìš”
- ìˆ˜ì‹  ë™ì˜ í™•ì¸ì€ í•„ìˆ˜ì…ë‹ˆë‹¤
- 080 ìˆ˜ì‹ ê±°ë¶€ ë²ˆí˜¸ë¥¼ ë°˜ë“œì‹œ í¬í•¨í•˜ì„¸ìš”
- ë°œì†¡ ì‹œê°„ê³¼ ì£¼ê¸°ë¥¼ ê´€ë¦¬í•˜ì—¬ ìŠ¤íŒ¸ìœ¼ë¡œ ë¶„ë¥˜ë˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•˜ì„¸ìš”
- ëŒ€ëŸ‰ ë°œì†¡ì€ ë°°ì¹˜ ì²˜ë¦¬ë¡œ ì„±ëŠ¥ì„ ìµœì í™”í•˜ì„¸ìš”
- A/B í…ŒìŠ¤íŠ¸ë¡œ ë©”ì‹œì§€ íš¨ê³¼ë¥¼ ì¸¡ì •í•˜ì„¸ìš”
